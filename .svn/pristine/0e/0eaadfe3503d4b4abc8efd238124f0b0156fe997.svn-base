using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;

namespace ExcelHelper
{
    public partial class AnalysisHelper
    {
        public static bool Analysis(string templateFilePath, ProcessReport report, ProcessReportClear reportClear, out List<Source> result, out Dictionary<string, string> contentConfig)
        {
            result = new List<Source>() { };
            contentConfig = new Dictionary<string, string>();
            reportClear();
            report("开始读取模板文件");
            ExcelHelper excelHelper = new ExcelHelper(templateFilePath);
            report("开始读取所有内容");
            Dictionary<string, string> AllContent = excelHelper.ReadAllContentText();
            if (AllContent.Count == 0)
            {
                report("解析失败，请修改配置后重试");
                return false;
            }
            report("开始读取数据源");
            if (!AllContent.Keys.Contains("1-1"))
            {
                MessageBox.Show("未读取到数据源，请在A1处配置数据源，如：\r\n标题(ds1=table;ds2=table2)");
                report("解析失败，请修改配置后重试");
                return false;
            }
            string strDBSource = AllContent["1-1"];
            Regex reg = new Regex(@"\((?<=\()[^\(]+(?<=\))$");
            Match match = reg.Match(strDBSource);
            if (!match.Success)
            {
                MessageBox.Show("数据源配置错误，请在A1处配置数据源，如：\r\n标题(ds1=table;ds2=table2)");
                report("解析失败，请修改配置后重试");
                return false;
            }
            Dictionary<string, string> DBSource = new Dictionary<string, string>();
            string strDB = match.Value.Replace("(", "").Replace(")", "").Replace("（", "").Replace("）", "").Replace("；", ";");
            try
            {
                string[] strDBs = strDB.Split(';');
                foreach (string oneDB in strDBs)
                {
                    int eqIndex = oneDB.IndexOf("=");
                    string dbKey = oneDB.Substring(0, eqIndex);
                    string dbTableName = oneDB.Substring(eqIndex + 1, oneDB.Length - eqIndex - 1);
                    DBSource.Add(dbKey, dbTableName);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show("数据源格式错误\r\n" + e.Message);
                report("解析失败，请修改配置后重试");
                return false;
            }
            if (DBSource.Count == 0)
            {
                MessageBox.Show("未找到任何数据源");
                report("解析失败，请修改配置后重试");
                return false;
            }
            report("开始读取所有正确配置");

            //找到所有含有数据源key的配置
            foreach (string key in DBSource.Keys)
            {
                Dictionary<string, string> keyConfig = AllContent.Where(x => x.Value.IndexOf(key) >= 0).ToDictionary(x => x.Key, y => y.Value);
                foreach (var item in keyConfig)
                {
                    if (!contentConfig.Keys.Contains(item.Key))
                    {
                        contentConfig.Add(item.Key, item.Value);
                    }
                }
            }
            Dictionary<string, string> dbConfig = new Dictionary<string, string>();
            //去除A1数据源配置
            contentConfig.Remove("1-1");
            //去除DownEnd和RightEnd
            dbConfig = contentConfig.Where(x => x.Value.ToLower().IndexOf("downend") < 0 && x.Value.ToLower().IndexOf("rightend") < 0).ToDictionary(x => x.Key, y => y.Value);
            dbConfig = dbConfig.OrderBy(x =>
            Convert.ToInt32(x.Key.Substring(0, x.Key.IndexOf("-")))
            ).ThenBy(x =>
            Convert.ToInt32(x.Key.Substring(x.Key.IndexOf("-") + 1, x.Key.Length - x.Key.IndexOf("-") - 1))
            ).ToDictionary(x => x.Key, y => y.Value);

            //生成解析实例
            foreach (string dbName in DBSource.Keys)
            {
                Source source = new Source()
                {
                    sourceName = dbName,
                    oracleTableName = DBSource[dbName],
                };
                Dictionary<string, string> dbGroup = dbConfig.Where(x => x.Value.StartsWith(dbName)).ToDictionary(x => x.Key, y => y.Value);
                if (dbGroup.Count(x => x.Value.ToLower().IndexOf("[down]") >= 0) > 0)
                {
                    source.sourceType = SourceType.Down;
                }
                else if (dbGroup.Count(x => x.Value.ToLower().IndexOf("[right]") >= 0) > 0)
                {
                    source.sourceType = SourceType.Right;
                }
                else
                {
                    source.sourceType = SourceType.Common;
                }
                List<SourceCol> sourceList = new List<SourceCol>() { };
                foreach (var item in dbGroup)
                {
                    int pointIndex = item.Value.IndexOf(".");
                    if (pointIndex == -1 || pointIndex + 1 == item.Value.Length)
                    {
                        MessageBox.Show("配置错误，" + GetPositionByKey(item.Key) + "列名为空");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                    int firstLeftBracketIndex = item.Value.IndexOf("[");
                    if (firstLeftBracketIndex == -1)
                    {
                        firstLeftBracketIndex = item.Value.Length;
                    }
                    SourceCol sourceCol = new SourceCol()
                    {
                        colName = item.Value.Substring(pointIndex + 1, firstLeftBracketIndex - pointIndex - 1),
                        position = item.Key,
                        isPublic = item.Value.ToLower().IndexOf("[public]") >= 0 ? true : false,
                        isFixed = item.Value.ToLower().IndexOf("[fixed]") >= 0 ? true : false,
                    };
                    sourceList.Add(sourceCol);
                }
                source.sourceCols = sourceList;
                result.Add(source);
            }
            //检测重复列名，列名不允许重复
            foreach (Source source in result)
            {
                var sourceColsGroupByName = source.sourceCols.GroupBy(x => x.colName);
                foreach (var item in sourceColsGroupByName)
                {
                    if (item.Count() > 1)
                    {
                        MessageBox.Show(source.sourceName + "列" + item.Key + "存在重复请检查");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                }
            }
            //检测down是否在一行，right是否在一列
            foreach (Source source in result)
            {
                if (source.sourceType == SourceType.Common)
                {
                    continue;
                }
                if (source.sourceType == SourceType.Down)
                {
                    var sourceColsGroupByName = source.sourceCols.GroupBy(x => x.rowIndex);
                    if (sourceColsGroupByName.Count() > 1)
                    {
                        MessageBox.Show(source.sourceName + "向下自增必须处于一行");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                }
                else if (source.sourceType == SourceType.Right)
                {
                    var sourceColsGroupByName = source.sourceCols.GroupBy(x => x.colIndex);
                    if (sourceColsGroupByName.Count() > 1)
                    {
                        MessageBox.Show(source.sourceName + "向右自增必须处于一列");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                }
            }

            //自增停止方式判定
            foreach (Source source in result)
            {
                if (source.sourceType == SourceType.Down)
                {
                    int index = contentConfig.Values.ToList().FindIndex(x => x.ToLower().IndexOf(source.sourceName + ".downend") >= 0);
                    int firstIndex = dbConfig.Values.ToList().FindIndex(x => x.ToLower().IndexOf(source.sourceName) >= 0);
                    if (index == -1)
                    {
                        continue;
                    }
                    string row1Key = contentConfig.Keys.ToList()[index];
                    string row2Key = dbConfig.Keys.ToList()[firstIndex];
                    string row1Value = contentConfig.Values.ToList()[index];
                    row1Value = row1Value.Replace("（", "(").Replace("）", ")");
                    Regex regex = new Regex(@".*(?=\(" + source.sourceName + @"\.downend\))", RegexOptions.IgnoreCase);
                    Match regMatch = regex.Match(row1Value);
                    if (regMatch.Value.Trim() == "")
                    {
                        MessageBox.Show(GetPositionByKey(row1Key) + "自增结束标识前必须有关键词");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                    source.stopKey = regMatch.Value;
                    int rowIndex1 = Convert.ToInt32(row1Key.Substring(0, row1Key.IndexOf("-")));
                    int rowIndex2 = Convert.ToInt32(row2Key.Substring(0, row2Key.IndexOf("-")));
                    if (rowIndex2 < rowIndex1)
                    {
                        source.stopType = StopType.StopWithSymbol;
                    }
                }
                else if (source.sourceType == SourceType.Right)
                {
                    int index = contentConfig.Values.ToList().FindIndex(x => x.ToLower().IndexOf(source.sourceName + ".rightend") >= 0);
                    int firstIndex = dbConfig.Values.ToList().FindIndex(x => x.ToLower().IndexOf(source.sourceName) >= 0);
                    if (index == -1)
                    {
                        continue;
                    }
                    string row1Key = contentConfig.Keys.ToList()[index];
                    string row2Key = dbConfig.Keys.ToList()[firstIndex];
                    string row1Value = contentConfig.Values.ToList()[index];
                    row1Value = row1Value.Replace("（", "(").Replace("）", ")");
                    Regex regex = new Regex(@".*(?=\(" + source.sourceName + @"\.rightend\))", RegexOptions.IgnoreCase);
                    Match regMatch = regex.Match(row1Value);
                    if (regMatch.Value.Trim() == "")
                    {
                        MessageBox.Show(GetPositionByKey(row1Key) + "自增结束标识前必须有关键词");
                        report("解析失败，请修改配置后重试");
                        return false;
                    }
                    source.stopKey = regMatch.Value;
                    int rowIndex1 = Convert.ToInt32(row1Key.Substring(row1Key.IndexOf("-") + 1, row1Key.Length - row1Key.IndexOf("-") - 1));
                    int rowIndex2 = Convert.ToInt32(row2Key.Substring(row2Key.IndexOf("-") + 1, row2Key.Length - row2Key.IndexOf("-") - 1));
                    if (rowIndex2 < rowIndex1)
                    {
                        source.stopType = StopType.StopWithSymbol;
                    }
                }
            }
            report("解析完成");
            return true;
        }

        public static bool GetDataByAnalysis(string importFilePath, Dictionary<string, string> contentConfig, List<Source> sources, ProcessReport report, ProcessReportClear reportClear, out List<DataTable> dataTables)
        {
            dataTables = new List<DataTable>() { };
            if (contentConfig == null || contentConfig.Count == 0 || sources == null || sources.Count == 0)
            {
                MessageBox.Show("规则未解析");
                return false;
            }
            reportClear();
            report("开始读取导入文件");
            ExcelHelper excelHelper = new ExcelHelper(importFilePath);
            report("开始读取所有内容");
            Dictionary<string, string> allContent = excelHelper.ReadAllContent();
            if (allContent.Count == 0)
            {
                report("解析失败，请修改配置后重试");
                return false;
            }
            report("开始解析规则匹配数据");

            Dictionary<string, string> dbConfig = contentConfig.Where(x => x.Value.ToLower().IndexOf("downend") < 0 && x.Value.ToLower().IndexOf("rightend") < 0).ToDictionary(x => x.Key, y => y.Value);

            Dictionary<string, string> dbConfig_h = dbConfig.OrderBy(x =>
            Convert.ToInt32(x.Key.Substring(0, x.Key.IndexOf("-")))
            ).ThenBy(x =>
            Convert.ToInt32(x.Key.Substring(x.Key.IndexOf("-") + 1, x.Key.Length - x.Key.IndexOf("-") - 1))
            ).ToDictionary(x => x.Key, y => y.Value);

            Dictionary<string, string> dbConfig_v = dbConfig.OrderBy(x =>
            Convert.ToInt32(x.Key.Substring(x.Key.IndexOf("-") + 1, x.Key.Length - x.Key.IndexOf("-") - 1))
            ).ThenBy(x =>
            Convert.ToInt32(x.Key.Substring(0, x.Key.IndexOf("-")))
            ).ToDictionary(x => x.Key, y => y.Value);

            //从第一个数据源开始计算修正 rowIndex 和 colIndex 并获取数据
            List<Source> allSourceTemp = sources.ToList();
            Dictionary<Source,List<List<string>>> data = new Dictionary<Source, List<List<string>>>() { };
            FixRowAndCol(sources.First(), allSourceTemp, allContent, ref data, false, false,0,0);
            foreach (var item in data)
            {
                DataTable dt = new DataTable();
                dt.TableName = item.Key.oracleTableName + "("+ item.Key.sourceName + ")";
                Source source = item.Key;
                foreach (SourceCol col in source.sourceCols)
                    dt.Columns.Add(col.colName);
                List<List<string>> dataRows = item.Value;
                for (int i = 0; i < dataRows.Count; i++)
                {
                    List<string> row = dataRows[i];
                    DataRow dr = dt.NewRow();
                    for (int j = 0; j < row.Count; j++)
                    {
                        dr[j] = row[j];
                    }
                    dt.Rows.Add(dr);
                }
                dataTables.Add(dt);
            }
            return true;
        }
        private static void FixRowAndCol(Source curSource, List<Source> allSourceTemp, Dictionary<string, string> allContent, ref Dictionary<Source, List<List<string>>> dataCollection, bool downEffected, bool rightEffected , int rowInc, int colInc)
        {
            allSourceTemp.Remove(curSource);
            List<List<string>> data = new List<List<string>>() { };
            List<Source> effectedDownDs = new List<Source>() { };
            List<Source> effectedRightDs = new List<Source>() { };
            switch (curSource.sourceType)
            {
                case SourceType.Down:
                    data = GetDownData(curSource, allContent, downEffected, rightEffected,rowInc, colInc);
                    rowInc += data.Count == 0 ? 1 : data.Count - 1;
                    effectedDownDs = GetEffectedDownDs(curSource, allSourceTemp);
                    break;
                case SourceType.Right:
                    data = GetRightData(curSource, allContent, downEffected, rightEffected, rowInc, colInc);
                    rowInc += data.Count == 0 ? 1 : data.Count - 1;
                    effectedRightDs = GetEffectedRightDs(curSource, allSourceTemp);
                    break;
                case SourceType.Common:
                    data = GetCommonData(curSource, allContent, downEffected, rightEffected, rowInc, colInc);
                    break;
                default:
                    break;
            }
            dataCollection.Add(curSource, data);
            if (allSourceTemp.Count == 0)
            {
                return;
            }
            downEffected = effectedDownDs.Contains(allSourceTemp.First());
            rightEffected = effectedRightDs.Contains(allSourceTemp.First());
            FixRowAndCol(allSourceTemp.First(), allSourceTemp, allContent, ref dataCollection, downEffected, rightEffected , rowInc, colInc);
        }

        private static List<Source> GetEffectedRightDs(Source source, List<Source> allSource)
        {
            List<Source> listSourceName = new List<Source>() { };
            foreach (Source item in allSource)
            {
                if (item.colIndexFullCollection.Count(x => x >= source.firstColNo) > 0)
                {
                    listSourceName.Add(item);
                }
            }
            return listSourceName;
        }

        private static List<Source> GetEffectedDownDs(Source source, List<Source> allSource)
        {
            List<Source> listSourceName = new List<Source>() { };
            foreach (Source item in allSource)
            {
                if (item.rowIndexFullCollection.Count(x => x >= source.firstRowNo) > 0)
                {
                    listSourceName.Add(item);
                }
            }
            return listSourceName;
        }
        private static List<List<string>> GetCommonData(Source source, Dictionary<string, string> allContent, bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<List<string>> result = new List<List<string>>() { };
            List<string> values = GetCommonValues(allContent, source, downEffected, rightEffected, rowInc, colInc);
            result.Add(values);
            return result;
        }

        private static List<List<string>> GetDownData(Source source, Dictionary<string, string> allContent,  bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<List<string>> result = new List<List<string>>() { };
            if (source.stopType == StopType.StopWithSymbol)
            {
                int rowIndex = source.firstRowNo;
                do
                {
                    List<string> values = GetDownValues(allContent, rowIndex, source, downEffected, rightEffected , rowInc, colInc);
                    rowIndex++;
                    if (values.Count(x => x.IndexOf(source.stopKey) >= 0) > 0)
                    {
                        break;
                    }
                    result.Add(values);
                } while (true);
            }
            else
            {
                int rowIndex = source.firstRowNo;
                do
                {
                    List<string> values = GetDownValues(allContent, rowIndex, source, downEffected, rightEffected, rowInc, colInc);
                    rowIndex++;
                    if (values.Count(x => x.Trim() == "") > 0)
                    {
                        break;
                    }
                    result.Add(values);
                } while (true);
            }
            return result;
        }
        private static List<List<string>> GetRightData(Source source, Dictionary<string, string> allContent, bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<List<string>> result = new List<List<string>>() { };
            if (source.stopType == StopType.StopWithSymbol)
            {
                int colIndex = source.firstColNo;
                do
                {
                    List<string> values = GetRightValues(allContent, colIndex, source, downEffected, rightEffected, rowInc, colInc);
                    colIndex++;
                    if (values.Count(x => x.IndexOf(source.stopKey) >= 0) > 0)
                    {
                        break;
                    }
                    result.Add(values);
                } while (true);
            }
            else
            {
                int colIndex = source.firstColNo;
                do
                {
                    List<string> values = GetRightValues(allContent, colIndex, source, downEffected, rightEffected, rowInc, colInc);
                    colIndex++;
                    if (values.Count(x => x.Trim() == "") > 0)
                    {
                        break;
                    }
                    result.Add(values);
                } while (true);
            }
            return result;
        }

        private static List<string> GetCommonValues(Dictionary<string, string> allContent, Source source, bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<string> result = new List<string>() { };
            for (int i = 0; i < source.sourceCols.Count; i++)
            {
                SourceCol item = source.sourceCols[i];
                int rowIndex = item.rowIndex;
                int colIndex = item.colIndex;
                //if (downEffected)
                    rowIndex += rowInc;
                //if (rightEffected)
                    colIndex += colInc;
                string key = string.Format("{0}-{1}", rowIndex, colIndex);
                if (item.isFixed)
                    key = string.Format("{0}-{1}", item.rowIndex, item.colIndex);
                if (allContent.ContainsKey(key))
                {
                    result.Add(allContent[key]);
                }
            }
            return result;
        }

        private static List<string> GetRightValues(Dictionary<string, string> allContent, int colIndex, Source source, bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<string> result = new List<string>() { };
            colIndex += colInc;
            for (int i = 0; i < source.sourceCols.Count; i++)
            {
                SourceCol item = source.sourceCols[i];
                int rowIndex = item.rowIndex;
                //if (downEffected)
                    rowIndex += rowInc;
                //if (rightEffected)
                string key = string.Format("{0}-{1}", rowIndex, colIndex);
                if (item.isPublic)
                    key = string.Format("{0}-{1}", rowIndex, source.firstColNo);
                if (item.isFixed)
                    key = string.Format("{0}-{1}", item.rowIndex , source.firstColNo);
                if (allContent.ContainsKey(key))
                {
                    result.Add(allContent[key]);
                }
            }
            return result;
        }

        private static List<string> GetDownValues(Dictionary<string, string> allContent, int rowIndex, Source source, bool downEffected, bool rightEffected, int rowInc, int colInc)
        {
            List<string> result = new List<string>() { };
            //if (downEffected)
            rowIndex += rowInc;
            //if (rightEffected)
            for (int i = 0; i < source.sourceCols.Count; i++)
            {
                SourceCol item = source.sourceCols[i];
                int colIndex = item.colIndex;
                colIndex += colInc;
                string key = string.Format("{0}-{1}", rowIndex, colIndex);
                if (item.isPublic)
                    key = string.Format("{0}-{1}", source.firstRowNo + rowInc, colIndex);
                if (item.isFixed)
                    key = string.Format("{0}-{1}", source.firstRowNo, item.colIndex);
                if (allContent.ContainsKey(key))
                {
                    result.Add(allContent[key]);
                }
            }
            return result;
        }

        private static string GetPositionByKey(string key)
        {
            int index = key.IndexOf("-");
            return ExcelHelper.NumToAlpha(Convert.ToInt32(key.Substring(index + 1, key.Length - index - 1)), false).ToString() + (Convert.ToInt32(key.Substring(0, index))).ToString();
        }

        private static int[] GetPositionIndexByKey(string key)
        {
            int[] result = new int[2];
            int index = key.IndexOf("-");
            result[0] = Convert.ToInt32(key.Substring(0, index));
            result[0] = Convert.ToInt32(key.Substring(index + 1, key.Length - index - 1));
            return result;
        }
    }
}
